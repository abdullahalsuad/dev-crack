## 1. What is Express.js?

**Express.js** is a lightweight and flexible web framework built on top of Node.js. It simplifies the process of creating web applications and APIs by providing ready-to-use tools for handling HTTP requests, managing routes, and processing data. Think of Express as a toolbox that makes it easier to build a website or a backend server without writing complex Node.js code from scratch.

**Why is it useful?**

It saves time by providing shortcuts for common tasks like routing and middleware.
It‚Äôs widely used for building RESTful APIs (e.g., for mobile apps) and web applications.
It has a huge community, so you can find plenty of tutorials and plugins.

üì¶ **Example:**
Imagine you want to create a website where users can visit different pages (like a homepage or about page). Express makes it easy to define what happens when users visit those pages without needing to handle low-level server details.

---

## 2. How do you install Express.js?

To use Express.js, you need to install it in your Node.js project using npm (Node Package Manager). This adds Express to your project so you can use its features.

üîπ **Steps to Install:**

1. Create a project folder and navigate to it:

```bash
mkdir my-express-app
cd my-express-app
```

2. Initialize a Node.js project (creates a `package.json` file):

```bash
npm init -y
```

3. Install Express.js:

```bash
npm install express
```

4. This command downloads Express and adds it to your project‚Äôs node_modules folder. It also updates package.json to list Express as a dependency.

üì¶ **Example:**

After running `npm install express`, you can verify it‚Äôs installed by checking package.json. You‚Äôll see something like:

```json
"dependencies": {
  "express": "^4.18.2"
}
```

Now you‚Äôre ready to use Express in your code!

---

## 3. How do you create a basic Express server?

Creating a basic Express server involves setting up a Node.js application that listens for HTTP requests and sends responses. Here‚Äôs a step-by-step breakdown of how to do it.

üì¶ **Code Example:**

```javascript
// 1. Import the Express module
const express = require("express");

// 2. Create an Express application
const app = express();

// 3. Define a port number for the server
const port = 3000;

// 4. Create a route for the homepage (GET request)
app.get("/", (req, res) => {
  res.send("Hello, this is my first Express server!");
});

// 5. Start the server
app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});
```

**Explanation:**

- Line 1: Imports Express so you can use its features.
- Line 2: Creates an instance of an Express app, which is the core of your server.
- Line 3: Sets the port (3000 is common for development).
- Line 4: Defines a route for the root URL (/) that responds to GET requests with a simple message.
- Line 5: Starts the server, making it listen for requests on http://localhost:3000.

**How to Run:**

1. Save the code in a file named app.js.
2. Run node app.js in your terminal.
3. Open a browser and go to http://localhost:3000. You‚Äôll see: Hello, this is my first Express server!

---

## 4. What is routing in Express?

Routing in Express is the process of determining how your application responds to client requests for specific URLs and HTTP methods (like GET or POST). Each route maps a URL pattern and HTTP method to a specific function that handles the request.

**Why is routing important?**

It organizes your app by defining what content or action corresponds to each URL.
For example, visiting /about might show an "About Us" page, while /contact shows a contact form.

üì¶ **Example:**

```javascript
const express = require("express");
const app = express();
const port = 3000;

// Route for homepage
app.get("/", (req, res) => {
  res.send("Welcome to the homepage!");
});

// Route for about page
app.get("/about", (req, res) => {
  res.send("This is the about page.");
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

When a user visits http://localhost:3000/, the server responds with "Welcome to the homepage!".
When they visit http://localhost:3000/about, it responds with "This is the about page.".
Express matches the URL and HTTP method (GET in this case) to the correct route.

---

## 5. What is middleware in Express?

Middleware in Express is like a middleman that processes requests before they reach your route handlers or after they leave them. It‚Äôs a function that has access to the req (request), res (response), and next (a function to pass control to the next middleware or route). Middleware can:

Modify the request or response (e.g., add data to req).
Perform tasks like logging, authentication, or parsing data.
End the request-response cycle or pass control to the next middleware.

üì¶ **Example:**

```javascript
const express = require("express");
const app = express();
const port = 3000;

// Middleware to log request details
app.use((req, res, next) => {
  console.log(`Received a ${req.method} request to ${req.url}`);
  next(); // Pass control to the next middleware or route
});

// Route
app.get("/", (req, res) => {
  res.send("Hello from the server!");
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

The middleware logs the HTTP method (e.g., GET) and URL (e.g., /) for every request.
`next()` ensures the request moves to the route handler.
When you visit http://localhost:3000, the console logs: Received a GET request to `/`, and the browser shows: Hello from the server!.

---

## 6. How do you use middleware in Express?

In Express, middleware is added using the `app.use()` function or by specifying it for specific routes. Middleware can be applied globally (for all requests) or to specific routes. The `express.json()` middleware, for example, parses incoming JSON data so you can access it in `req.body`.

üîπ **Steps to Use Middleware:**

Define or import the middleware.
Use `app.use()` to apply it globally or pass it to a specific route.
Ensure the middleware calls `next()` if it should pass control to the next handler.

üì¶ **Example:**

```javascript
const express = require("express");
const app = express();
const port = 3000;

// Use built-in middleware to parse JSON
app.use(express.json());

// Custom middleware to log request time
app.use((req, res, next) => {
  console.log(`Request received at: ${new Date().toISOString()}`);
  next();
});

// Route to handle POST request
app.post("/data", (req, res) => {
  console.log("Received data:", req.body);
  res.send("Data received!");
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

`app.use(express.json())`: Parses JSON data sent in POST requests.
Custom middleware logs the time of each request.
The `/data` route logs the JSON data sent in the request body.
Test it using a tool like Postman: Send a POST request to http://localhost:3000/data with JSON like `{"name": "John"}`. The console shows the data, and the browser shows "Data received!".

---

## 7. What are route parameters?

Route parameters are dynamic parts of a URL that you define using a colon (`:`) in your route path. They allow you to capture values from the URL and use them in your route handler. For example, `/users/:id` captures the `id` value from the URL and makes it available in `req.params`.

**Why use route parameters?**

- They make routes flexible, allowing you to handle dynamic data (e.g., user IDs, product IDs).
- Common for APIs or pages that display specific data.
  Example:

üì¶ **Example:**

```javascript
const express = require("express");
const app = express();
const port = 3000;

app.get("/users/:id", (req, res) => {
  const userId = req.params.id; // Get the :id value from the URL
  res.send(`You requested user with ID: ${userId}`);
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

Visiting http://localhost:3000/users/123 shows: `You requested user with ID: 123`.
Visiting http://localhost:3000/users/abc shows: `You requested user with ID: abc`.
The `:id` in the route captures whatever value is in that part of the URL and stores it in `req.params.id`.

---

## 8. How do you handle POST requests in Express?

POST requests are used to send data to the server, such as form submissions or API data. In Express, you handle POST requests using `app.post()` and often use the `express.json()` middleware to parse incoming JSON data.

üîπ **Steps:**

1. Use `app.use(express.json())` to parse JSON data.
2. Define a route with `app.post()` to handle the POST request.
3. Access the sent data in `req.body` and send a response.

üì¶ **Example:**

```javascript
const express = require("express");
const app = express();
const port = 3000;

// Middleware to parse JSON
app.use(express.json());

// Handle POST request
app.post("/users", (req, res) => {
  const user = req.body; // Get data from request body
  res.send(`User ${user.name} created successfully!`);
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- Send a POST request to http://localhost:3000/users with JSON like `{"name": "Alice"}` (use Postman or curl).
- The server reads the JSON data (`req.body`) and responds with: `User Alice created successfully!`.
- Without `express.json()`, `req.body` would be undefined.

---

## 9. What is express.json()?

`express.json()` is a built-in Express middleware that parses incoming requests with JSON payloads. It takes the JSON data sent in the request body (e.g., from a form or API call) and converts it into a JavaScript object, making it available in `req.body`.

**Why is it needed?**

- Many POST or PUT requests send data in JSON format.
- Without `express.json()`, you can‚Äôt easily access this data.

```javascript
const express = require("express");
const app = express();
const port = 3000;

// Enable JSON parsing
app.use(express.json());

app.post("/submit", (req, res) => {
  const data = req.body; // Access JSON data
  res.send(`Received: ${data.message}`);
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- Send a POST request to http://localhost:3000/submit with JSON: `{"message": "Hello"}`.
- The `express.json()` middleware parses the JSON, so `req.body.message` is "Hello".
- The server responds: `Received: Hello`.

---

## 10. What is express.static()?

`express.static()` is a built-in Express middleware that serves static files (like HTML, CSS, images, or JavaScript) from a specified folder. When a client requests a file, Express automatically sends it without needing a custom route.

**Why use it?**

- Simplifies serving assets like stylesheets, scripts, or images for your web app.
- No need to write routes for each file.

üì¶ **Example:**

1. Create a folder named `public` in your project with an `index.html` file:

```html
<!-- public/index.html -->
<h1>Welcome to my site!</h1>
```

2. Set up your Express app:

```javascript
const express = require("express");
const app = express();
const port = 3000;

// Serve static files from the 'public' folder
app.use(express.static("public"));

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- Visiting http://localhost:3000/index.html serves the `index.html` file from the `public` folder.
- If you add `public/styles.css`, it‚Äôs available at http://localhost:3000/styles.css.
- The `public` folder acts like the root directory for static files.

---

## 11. How do you handle errors in Express?

Express allows you to handle errors using special error-handling middleware. This middleware has four parameters (`err`, `req`, `res`, `next`) and is called when an error occurs in your app. You can use it to send custom error messages or log errors.

üîπ **Steps:**

- Define error-handling middleware at the end of your middleware stack.
- Use `next(err)` in routes to pass errors to this middleware.
- Send a response with an error message and status code.

üì¶ **Example:**

```javascript
const express = require("express");
const app = express();
const port = 3000;

app.get("/", (req, res, next) => {
  try {
    throw new Error("Something went wrong!");
  } catch (err) {
    next(err); // Pass error to error-handling middleware
  }
});

// Error-handling middleware
app.use((err, req, res, next) => {
  console.error(err.message); // Log the error
  res.status(500).send("Oops, something broke!");
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

The `/` route throws an error, which is passed to the error-handling middleware via `next(err)`.
The middleware catches the error, logs it, and sends a 500 status with a message.
Visiting http://localhost:3000 shows: `Oops, something broke!`.

---

## 12. What is the difference between `app.get()` and `app.use()`?

In Express, `app.get()` and `app.use()` serve different purposes:

`app.get(path, callback)`
Defines a route handler for **GET requests** to a specific URL path. It‚Äôs used to send responses for specific routes and HTTP methods.

`app.use([path], callback)`
Applies middleware or route handlers to **all HTTP methods** (`GET`, `POST`, etc.) for a given path (or **all paths** if no path is specified). It‚Äôs commonly used for middleware.

**Key Differences:**

- `app.get()` is **specific to GET requests**; `app.use()` applies to **all HTTP methods**.
- `app.get()` is typically used for **routes**; `app.use()` is used for **middleware** or general-purpose handlers.
- `app.use()` can take an **optional path**, while `app.get()` **always requires a path**.

---

üì¶ **Example:**

```js
const express = require("express");
const app = express();
const port = 3000;

// Middleware with app.use
app.use((req, res, next) => {
  console.log("This runs for ALL requests");
  next();
});

// Route with app.get
app.get("/home", (req, res) => {
  res.send("Welcome to the home page!");
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- The `app.use` middleware logs a message for all requests, regardless of the URL or method.
- The `app.get` route only responds to GET requests to /home.
- Visiting http://localhost:3000/home logs the middleware message and shows: `Welcome to the home page!`.

---

## 13. What is req.body?

`req.body` is an object in Express that contains data sent by the client in the body of a request, typically in POST or PUT requests. This data could come from HTML forms, JSON payloads, or other sources. To use `req.body`, you need middleware like `express.json()` or `express.urlencoded()` to parse the data.

**Why is it useful?**

- It lets you access user-submitted data, like form inputs or API data.

üì¶ **Example:**

```js
const express = require("express");
const app = express();
const port = 3000;

// Middleware to parse JSON
app.use(express.json());

app.post("/signup", (req, res) => {
  const { username } = req.body; // Access data from request body
  res.send(`Welcome, ${username}!`);
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- Send a POST request to http://localhost:3000/signup with JSON: `{"username": "Bob"}`.
- The `express.json()` middleware parses the JSON, `so req.body.username` is "Bob".
- The server responds: `Welcome, Bob!`.

---

## 14. What is req.params?

`req.params` is an object in Express that holds the values of route parameters (dynamic parts of the URL defined with a colon, `:`). These parameters allow you to capture specific values from the URL to use in your route handler.

üì¶ **Example:**

```js
const express = require("express");
const app = express();
const port = 3000;

app.get("/books/:bookId", (req, res) => {
  const bookId = req.params.bookId; // Get the :bookId value
  res.send(`You requested book ID: ${bookId}`);
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- The route `/books/:bookId` matches URLs like `/books/123` or `/books/abc`.
- Visiting http://localhost:3000/books/123 sets `req.params.bookId` to "123".
- The server responds: `You requested book ID: 123`.

---

## 15. What is req.query?

`req.query` is an object in Express that contains key-value pairs from the query string in a URL. The query string is the part of the URL after a ?, where parameters are written as key=value pairs, separated by &.

**Why use it?**

Query parameters are often used for filtering, searching, or passing optional data (e.g., search terms, page numbers).

üì¶ **Example:**

```js
const express = require("express");
const app = express();
const port = 3000;

app.get("/search", (req, res) => {
  const searchTerm = req.query.q; // Get the 'q' query parameter
  res.send(`You searched for: ${searchTerm}`);
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- Visiting http://localhost:3000/search?q=javascript sets `req.query.q` to "javascript".
- The server responds: You searched for: javascript.
- Multiple query parameters (e.g., `/search?q=javascript&sort=asc`) are available as `req.query.q` and `req.query.sort`.

---

## 16. How do you set up CORS in Express?

CORS (Cross-Origin Resource Sharing) allows your Express server to accept requests from different domains (e.g., a frontend app hosted on a different server). The cors package simplifies enabling CORS in Express.

üîπ **Steps:**

1. Install the cors package:

```bash
npm install cors
```

2. Use the cors middleware in your app.

üì¶ **Example:**

```js
const express = require("express");
const cors = require("cors");
const app = express();
const port = 3000;

// Enable CORS for all routes
app.use(cors());

app.get("/data", (req, res) => {
  res.json({ message: "This data can be accessed from any domain!" });
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- The cors middleware adds headers to allow cross-origin requests.
- A frontend app on http://example.com can now fetch data from http://localhost:3000/data.
- You can customize CORS (e.g., allow specific domains) by passing options to `cors()`.

---

## 17. What is `app.listen()`?

`app.listen(port, [callback])` is an Express method that starts your server, making it listen for incoming HTTP requests on a specified port. The optional callback function runs when the server starts successfully.

**Why is it important?**

It‚Äôs the final step to make your app accessible to clients (e.g., browsers or API clients).

üì¶ **Example:**

```js
const express = require("express");
const app = express();
const port = 3000;

app.get("/", (req, res) => {
  res.send("Server is up!");
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- `app.listen(3000, ...)` binds the server to port 3000.
- The callback logs a message when the server starts.
- Visiting http://localhost:3000 shows: Server is up!.

---

## 18. How do you serve HTML files in Express?

To serve HTML files in Express, you use `res.sendFile()` to send a specific file to the client. The path module is often used to create absolute file paths to avoid errors across different operating systems.

üîπ **Steps:**

1. Create an HTML file in your project (e.g., `public/index.html`).
2. Use `res.sendFile()` with the absolute path to the file.
3. Optionally, use `express.static()` to serve the entire folder containing the HTML file.

üì¶ **Example:**

- Create public/index.html:

```html
<h1>My Express Website</h1>
<p>Welcome to my page!</p>
```

- Set up your Express app: javascript

```js
const express = require('express');
const path = require('path');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
res.sendFile(path.join(\_\_dirname, 'public', 'index.html'));
});

app.listen(port, () => {
console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- `path.join(\_\_dirname, 'public', 'index.html')` creates the absolute path to index.html.
- Visiting http://localhost:3000 displays the HTML
- content: My Express Website and Welcome to my page!.

---

## 19. What is the purpose of `next()` in middleware?

In Express middleware, `next()` is a function that passes control to the next middleware or route handler in the chain. If you don‚Äôt call `next()`, the request will hang, and the client won‚Äôt receive a response.

**Why is it needed?**

Middleware often performs tasks (e.g., logging, authentication) and then hands off the request to the next handler.
`next()` ensures the request continues processing.

üì¶ **Example:**

```js
const express = require("express");
const app = express();
const port = 3000;

// Middleware 1
app.use((req, res, next) => {
  console.log("Middleware 1: Logging request");
  next(); // Move to the next middleware
});

// Middleware 2
app.use((req, res, next) => {
  console.log("Middleware 2: Adding timestamp");
  req.timestamp = new Date();
  next(); // Move to the route
});

// Route
app.get("/", (req, res) => {
  res.send(`Request processed at: ${req.timestamp}`);
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- Middleware 1 logs a message and calls `next()` to pass control.
- Middleware 2 adds a timestamp to req and calls `next()`.
- The route uses the timestamp and sends a response.
- Visiting http://localhost:3000 shows something like: `Request processed at: 2025-07-28T16:34:00.000Z`.

---

## 20. How do you handle 404 errors in Express?

A 404 error occurs when a client requests a route that doesn‚Äôt exist. In Express, you handle 404 errors by adding a middleware function at the end of your middleware and route stack. This middleware catches any unmatched requests and sends a 404 response.

üîπ **Steps:**

1. Place the 404 middleware after all routes.
2. Use `res.status(404)` to set the HTTP status and send a response.

üì¶ **Example:**

```js
const express = require("express");
const app = express();
const port = 3000;

app.get("/", (req, res) => {
  res.send("Home page");
});

// 404 middleware (must be last)
app.use((req, res) => {
  res.status(404).send("Page not found!");
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- Visiting http://localhost:3000/ shows: Home page.
- Visiting http://localhost:3000/random (an undefined route) shows: Page not found! with a 404 status code.

---

## 21. What is Express Router?

Express Router is a feature in Express.js that lets you group related routes and middleware into a separate, reusable module. It‚Äôs like a mini Express app that handles specific routes, making your code more organized and easier to maintain, especially for large apps.

**Why use it?**

- Keeps your main app.js file clean by moving routes to separate files.
- Makes routes reusable across different parts of your app.
- Simplifies managing related routes (e.g., all user-related routes in one place).

üì¶ **Example:**

- Create a file named userRoutes.js:

```javascript
const express = require("express");
const router = express.Router();

router.get("/", (req, res) => {
  res.send("List of users");
});

router.get("/:id", (req, res) => {
  res.send(`User with ID: ${req.params.id}`);
});

module.exports = router;
```

- Use it in app.js:

```javascript
const express = require("express");
const app = express();
const port = 3000;

const userRoutes = require("./userRoutes");
app.use("/users", userRoutes);

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- `express.Router()` creates a router instance.
- Routes defined in userRoutes.js handle requests to /users (e.g., http://localhost:3000/users shows "List of users").
- /users/:id handles requests like http://localhost:3000/users/123, showing "User with ID: 123".

---

## 22. How do you use Express Router?

Using Express Router involves creating a router instance, defining routes on it, and then mounting it on your Express app with `app.use()`. This lets you organize routes into separate files and attach them to specific paths.

üîπ **Steps:**

1. Create a router in a separate file (e.g., routes/users.js).
2. Define routes using `router.get()`, `router.post()`, etc.
   Export the router and use it in your main app with `app.use()`.

üì¶ **Example:**

- Create routes/users.js:

```javascript
const express = require("express");
const router = express.Router();

router.get("/", (req, res) => {
  res.send("All users");
});

router.get("/profile", (req, res) => {
  res.send("User profile page");
});

module.exports = router;
```

- Use it in app.js:

```javascript
const express = require("express");
const app = express();
const port = 3000;

const userRoutes = require("./routes/users");
app.use("/users", userRoutes);

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- Visiting http://localhost:3000/users shows "All users".
- Visiting http://localhost:3000/users/profile shows "User profile page".
- `app.use('/users', userRoutes)` mounts the router so all its routes start with /users.

---

## 23. What is a template engine in Express?

A template engine in Express is a tool that lets you create dynamic HTML pages by combining HTML with data (e.g., from a database or user input). Unlike static HTML, template engines allow you to insert variables, loops, or conditions into your HTML, making your pages dynamic.

**Why use a template engine?**

- Generate HTML dynamically (e.g., display a user‚Äôs name).
- Reuse HTML templates for multiple pages.
- Simplify building web apps with dynamic content.

üì¶ **Example (using EJS):**

1. Install EJS:

```bash
npm install ejs
```

2. Set up `app.js`:

```javascript
const express = require("express");
const app = express();
const port = 3000;

app.set("view engine", "ejs");

app.get("/", (req, res) => {
  res.render("index", { name: "Alice" });
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

3. Create `views/index.ejs`:

```html
<h1>Hello, <%= name %>!</h1>
```

‚öôÔ∏è **How it works:**

- `app.set('view engine', 'ejs')` tells Express to use EJS as the template engine.
- `res.render('index', { name: 'Alice' })` renders `index.ejs`, replacing `<%= name %>` with "Alice".
- Visiting http://localhost:3000 shows: `<h1>Hello, Alice!</h1>`.

---

## 24. How do you set a template engine in Express?

To use a template engine in Express, you need to configure Express to recognize the engine and specify where to find template files. The most common template engines are EJS, Pug, and Handlebars. Here, we‚Äôll use EJS as an example.

üîπ **Steps:**

1. Install the template engine (e.g., `npm install ejs`).
2. Set the view engine with `app.set('view engine', 'ejs')`.
3. Create a `views` folder and add template files (e.g., `.ejs` files).
4. Use `res.render()` to render templates with data.

üì¶ **Example:**

1. Install EJS:

```bash
npm install ejs
```

2. Create `app.js`:

```javascript
const express = require("express");
const app = express();
const port = 3000;

app.set("view engine", "ejs");
```

3. Create `views/home.ejs`:

```html
<h1><%= title %></h1>
<p>Welcome, <%= user %>!</p>
```

4. Use it in `app.js`:

```javascript
const express = require("express");
const app = express();
const port = 3000;

app.set("view engine", "ejs");

app.get("/", (req, res) => {
  res.render("home", { title: "My App", user: "Bob" });
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- `app.set('view engine', 'ejs')` configures Express to use EJS.
- Express looks for templates in the `views` folder by default.
- `res.render('home', { title: 'My App', user: 'Bob' })` renders `home.ejs` with the provided data.
- Visiting http://localhost:3000 shows: `<h1>My App</h1><p>Welcome, Bob!</p>`.

---

## 25. What is cookie-parser?

cookie-parser is an Express middleware that parses cookies sent in HTTP requests and makes them available in `req.cookies` as a JavaScript object. Cookies are small pieces of data stored in the client‚Äôs browser, often used for user authentication, session management, or storing preferences.

**Why use it?**

Simplifies reading cookies from requests.
Essential for features like user sessions or tracking.

üì¶ **Example:**

1. Install cookie-parser:

```bash
npm install cookie-parser
```

2. Set up app.js:

```js
const express = require("express");
const cookieParser = require("cookie-parser");
const app = express();
const port = 3000;

app.use(cookieParser());

app.get("/", (req, res) => {
  res.cookie("username", "Alice"); // Set a cookie
  res.send(
    `Cookie set! Current cookies: ${JSON.stringify(req.cookies)}`
  );
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- `app.use(cookieParser())` enables cookie parsing.
- `res.cookie('username', 'Alice')` sets a cookie named username with value Alice.
- `req.cookies` contains all cookies sent by the client.
- Visiting http://localhost:3000 shows: Cookie set! Current cookies: `{"username":"Alice"}`.

---

## 26. How do you handle file uploads in Express?

To handle file uploads in Express, you use the multer middleware, which processes multipart form data (e.g., files uploaded via forms). It saves files to your server and provides details about them in `req.file` or `req.files`.

üîπ **Steps:**

- Install multer: `npm install multer`.
- Configure multer to specify where to save files and how to name them.
- Create a route to handle file uploads.
- Use an HTML form to send files.

üì¶ **Example:**

1. Install multer:

```bash
npm install multer
```

2. Create app.js:

```js
const express = require("express");
const multer = require("multer");
const app = express();
const port = 3000;

const upload = multer({ dest: "uploads/" });

app.get("/", (req, res) => {
  res.send(`
    <form action="/upload" method="post" enctype="multipart/form-data">
      <input type="file" name="photo">
      <button type="submit">Upload</button>
    </form>
  `);
});

app.post("/upload", upload.single("photo"), (req, res) => {
  res.send(`File uploaded: ${req.file.filename}`);
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- `multer({ dest: 'uploads/' })` saves uploaded files to an uploads folder.
- `upload.single('photo')` processes a single file upload with the name photo.
- The form at `/` lets users upload a file.
- Visiting http://localhost:3000, uploading a file, and submitting shows: `File uploaded: <random-filename>`.

---

## 27. What is a session in Express?

A session in Express is a way to store user data on the server across multiple requests, allowing you to maintain state (e.g., keeping a user logged in). The express-session middleware manages sessions by storing data in memory or a database and linking it to the client via a cookie.

**Why use sessions?**

- Track user activity (e.g., login status).
- Store temporary data, like a shopping cart.

üì¶ **Example:**

1. Install express-session:

```bash
npm install express-session
```

2. Set up app.js:

```js
const express = require("express");
const session = require("express-session");
const app = express();
const port = 3000;

app.use(
  session({
    secret: "my-secret-key",
    resave: false,
    saveUninitialized: false,
  })
);

app.get("/", (req, res) => {
  req.session.views = (req.session.views || 0) + 1;
  res.send(`You visited this page ${req.session.views} times`);
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- `app.use(session({...}))` sets up session management with a secret key.
- `req.session.views` stores the number of page visits for the user.
- Visiting http://localhost:3000 multiple times increments the count: "You visited this page 1 times", "You visited this page 2 times", etc.

---

## 28. What is the difference between `res.send()` and `res.json()`?

Both `res.send()` and `res.json()` send responses to the client in Express, but they differ in how they handle data and headers:

- `res.send()`: Sends any type of data (string, HTML, object, etc.) and sets the Content-Type header based on the data type.

- `res.json()`: Converts the data to JSON, sets the Content-Type to application/json, and sends it.
  When to use each?

Use `res.send()` for simple responses like strings or HTML.
Use `res.json() for` APIs where JSON data is expected.

üì¶ **Example:**

```js
const express = require("express");
const app = express();
const port = 3000;

app.get("/send", (req, res) => {
  res.send("Hello, this is a string!");
});

app.get("/json", (req, res) => {
  res.json({ message: "This is JSON data", user: "Alice" });
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- http://localhost:3000/send: Shows `"Hello, this is a string!"` with Content-Type: text/html.
- http://localhost:3000/json: Shows `{"message":"This is JSON data","user":"Alice"}` with Content-Type: application/json.

---

## 29. How do you validate input in Express?

Input validation in Express ensures that data sent by clients (e.g., in forms or API requests) meets your requirements (e.g., valid email, required fields). Libraries like express-validator or joi simplify this by providing tools to check and sanitize data.

üîπ **Steps: (using express-validator)**:

- Install express-validator: `npm install express-validator`.
- Add validation middleware to your route.
- Check for errors and respond accordingly.

üì¶ **Example:**

1. Install express-validator:

```bash
npm install express-validator
```

2. Set up app.js:

```js
const express = require("express");
const { body, validationResult } = require("express-validator");
const app = express();
const port = 3000;

app.use(express.json());

app.post(
  "/register",
  body("email").isEmail(),
  body("password").isLength({ min: 6 }),
  (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    res.send(`Welcome, ${req.body.email}!`);
  }
);

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- `body('email').isEmail()` checks if email is a valid email.
- `body('password').isLength({ min: 6 })` ensures password is at least 6 characters.
- Send a POST request to http://localhost:3000/register with JSON like `{"email": "test@example.com", "password": "123456"}` to get: `Welcome, test@example.com!`.
- If you send `{"email": "invalid", "password": "123"}`, you get a 400 error with validation details.

---

## 30. What is rate limiting in Express?

Rate limiting in Express restricts the number of requests a client (e.g., a user or bot) can make to your server in a given time period. This prevents abuse, like spamming your API. The express-rate-limit middleware is commonly used to enforce these limits.

**Why use it?**

- Protects your server from overload or denial-of-service attacks.
- Ensures fair usage of your API.

üì¶ **Example:**

1. Install express-rate-limit:

```bash
npm install express-rate-limit
```

2. Set up app.js:

```js
const express = require('express');
const rateLimit = require('express-rate-limit');
const app = express();
const port = 3000;

const limiter = rateLimit({
windowMs: 15 _ 60 _ 1000, // 15 minutes
max: 5 // 5 requests per IP
});

app.use(limiter);

app.get('/', (req, res) => {
res.send('Hello, this is a rate-limited route!');
});

app.listen(port, () => {
console.log(`Server running at http://localhost:${port}`);
});
```

‚öôÔ∏è **How it works:**

- `rateLimit({ windowMs: 15 _ 60 _ 1000, max: 5 }) `limits each IP to 5 requests every 15 minutes.
- Visiting http://localhost:3000 more than 5 times in 15 minutes returns a `429 (Too Many Requests) error`.
- The response for successful requests is: `Hello, this is a rate-limited route!`.
